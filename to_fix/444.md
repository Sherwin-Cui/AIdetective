修改方案概览
1. 数据结构改动

修改对话历史记录格式，支持每轮对话附带证据
新增证据分析系统，实时跟踪证明进度
调整结局判定逻辑，支持动态判断

2. UI交互改动

移除原有的证据选择模态框
在对话输入框旁添加"附加证据"按钮
实时显示当前需要证明的要素
第一次对话自动发送"XXX，你就是凶手！"

3. 系统逻辑改动

实现新的证据评分系统
动态判断通关条件
基于AI响应更新UI提示

详细修改步骤
步骤1：修改 AccusationSystem.js
javascript// 1. 修改数据结构
export const AccusationSystem = {
    // ... 现有属性
    dialogueHistory: [], // 修改为新格式
    submittedEvidence: {
        all: [], // 所有提交的证据
        byType: {
            motive: [],
            method: [],
            opportunity: [],
            conspiracy: []
        }
    },
    currentProofPrompt: '', // 当前需要证明的内容
    evidenceAnalysis: {
        proven: [],
        pending: []
    },
    
    // 2. 新增证据附加功能
    attachedEvidence: [], // 当前对话附加的证据
    
    // 3. 修改对话历史记录方法
    addToHistory(detectiveMsg, npcResponse, attachedEvidence = []) {
        this.dialogueHistory.push({
            detective: detectiveMsg,
            npc: npcResponse.text,
            emotion: npcResponse.emotion,
            evidenceSubmitted: attachedEvidence
        });
        
        // 更新已提交证据
        if (attachedEvidence.length > 0) {
            this.submittedEvidence.all.push(...attachedEvidence);
            this.analyzeEvidence();
        }
    },
    
    // 4. 新增证据分析方法
    analyzeEvidence() {
        const evidenceConfig = {
            motive: ['clue_will_draft', 'clue_deduce_inheritance_crisis', 'clue_love_letter'],
            method: ['clue_poison_bottle', 'clue_deduce_poison_source', 'clue_doctor_drug_interaction'],
            opportunity: ['clue_chen_cellar', 'clue_maid_witness', 'clue_cellar_key'],
            conspiracy: ['clue_butler_dismiss_maid', 'clue_chen_butler_relationship', 'clue_deduce_conspiracy']
        };
        
        this.evidenceAnalysis.proven = [];
        this.evidenceAnalysis.pending = [];
        
        for (const [type, required] of Object.entries(evidenceConfig)) {
            const submitted = this.submittedEvidence.all.filter(e => required.includes(e));
            if (submitted.length > 0) {
                this.evidenceAnalysis.proven.push({
                    type,
                    evidence: submitted
                });
            } else {
                this.evidenceAnalysis.pending.push({
                    type,
                    required
                });
            }
        }
    },
    
    // 5. 修改开始对决方法
    async startConfrontation() {
        const modal = document.getElementById('confrontation-modal');
        const dialogueContainer = document.getElementById('confrontation-dialogue');
        
        dialogueContainer.innerHTML = '';
        modal.style.display = 'flex';
        
        // 自动发送第一条消息
        const firstMessage = `${NpcData[this.currentAccused].name}，你就是凶手！`;
        
        // 禁用输入
        this.isWaitingForResponse = true;
        document.getElementById('accusation-input').disabled = true;
        document.getElementById('accusation-send').disabled = true;
        
        // 添加侦探的第一条对话
        await this.addDialogue('detective', firstMessage);
        
        // 生成NPC的第一次响应
        const response = await this.generateNPCResponse(firstMessage);
        await this.processNPCResponse(response);
        
        // 恢复输入
        this.isWaitingForResponse = false;
        document.getElementById('accusation-input').disabled = false;
        document.getElementById('accusation-send').disabled = false;
        document.getElementById('accusation-input').focus();
    },
    
    // 6. 修改发送消息方法
    async sendAccusation() {
        const input = document.getElementById('accusation-input');
        const message = input.value.trim();
        
        if (!message || this.isWaitingForResponse) return;
        
        // 获取附加的证据
        const attachedEvidence = this.attachedEvidence.slice();
        
        this.isWaitingForResponse = true;
        input.value = '';
        input.disabled = true;
        
        // 显示带证据的对话
        let displayMessage = message;
        if (attachedEvidence.length > 0) {
            const evidenceNames = this.getEvidenceNames(attachedEvidence);
            displayMessage += ` [附带证据：${evidenceNames.join('、')}]`;
        }
        
        await this.addDialogue('detective', displayMessage);
        
        // 生成完整的用户消息（用于AI）
        let fullMessage = message;
        if (attachedEvidence.length > 0) {
            fullMessage = `${message}\n（用户提交了证据：${attachedEvidence.join('、')}）`;
        }
        
        // 生成响应
        const response = await this.generateNPCResponse(fullMessage);
        
        // 记录到历史
        this.addToHistory(message, response, attachedEvidence);
        
        // 清空附加证据
        this.attachedEvidence = [];
        this.updateAttachedEvidenceUI();
        
        await this.processNPCResponse(response);
        
        this.isWaitingForResponse = false;
        input.disabled = false;
        input.focus();
    },
    
    // 7. 修改响应处理方法
    async processNPCResponse(response) {
        const npc = NpcData[this.currentAccused];
        
        // 添加NPC对话
        await this.addDialogue('npc', response.text, npc.avatar, response.emotion);
        
        // 处理系统控制信息
        if (response.systemControl) {
            const control = response.systemControl;
            
            // 更新下一步证明提示
            if (control.next_proof_prompt) {
                this.currentProofPrompt = control.next_proof_prompt;
                this.updateProofPromptUI(control.next_proof_prompt);
            }
            
            // 更新压力等级
            if (control.pressure_level) {
                this.pressureLevel = control.pressure_level;
                document.getElementById('pressure-level').textContent = 
                    this.getPressureLevelText(control.pressure_level);
            }
            
            // 检查结局
            if (control.ending_check) {
                if (control.ending_check.perfect_ending) {
                    setTimeout(() => this.showEnding('perfect'), 2000);
                } else if (control.ending_check.good_ending) {
                    setTimeout(() => this.showEnding('good'), 2000);
                }
            }
        }
    },
    
    // 8. 新增UI更新方法
    updateProofPromptUI(prompt) {
        let promptElement = document.getElementById('current-proof-prompt');
        if (!promptElement) {
            // 创建提示元素
            const header = document.querySelector('.confrontation-header');
            promptElement = document.createElement('div');
            promptElement.id = 'current-proof-prompt';
            promptElement.className = 'proof-prompt';
            header.appendChild(promptElement);
        }
        promptElement.innerHTML = `<strong>当前需要：</strong>${prompt}`;
    },
    
    // 9. 新增证据附加UI
    showEvidenceAttachment() {
        const modal = document.createElement('div');
        modal.id = 'evidence-attachment-modal';
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content">
                <h3>选择要附加的证据</h3>
                <div id="attachment-evidence-grid" class="evidence-grid"></div>
                <div class="attachment-controls">
                    <button onclick="AccusationSystem.confirmAttachment()">确认</button>
                    <button onclick="AccusationSystem.cancelAttachment()">取消</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // 显示可用证据
        const grid = document.getElementById('attachment-evidence-grid');
        const collectedClues = AIClueManager.getTriggeredClues();
        
        collectedClues.forEach(clueId => {
            const clueData = AIClueManager.getClueById(clueId);
            if (!clueData) return;
            
            const item = document.createElement('div');
            item.className = 'evidence-item';
            if (this.attachedEvidence.includes(clueId)) {
                item.classList.add('selected');
            }
            
            item.innerHTML = `
                <img src="${clueData.img}" alt="${clueData.name}">
                <div>${clueData.name}</div>
            `;
            
            item.onclick = () => this.toggleAttachedEvidence(clueId);
            grid.appendChild(item);
        });
        
        modal.style.display = 'flex';
    },
    
    toggleAttachedEvidence(clueId) {
        const index = this.attachedEvidence.indexOf(clueId);
        if (index > -1) {
            this.attachedEvidence.splice(index, 1);
        } else {
            this.attachedEvidence.push(clueId);
        }
        
        // 更新UI
        const item = document.querySelector(`[data-clue-id="${clueId}"]`);
        if (item) {
            item.classList.toggle('selected');
        }
    }
};
步骤2：修改 UI 部分
javascript// 在 createAccusationUI 方法中修改对决界面
confrontModal.innerHTML = `
    <div class="modal-content confrontation-content">
        <div class="confrontation-header">
            <h2 id="confrontation-title">指认对决</h2>
            <div id="current-proof-prompt" class="proof-prompt"></div>
            <div id="pressure-indicator" class="pressure-indicator">
                压力等级: <span id="pressure-level">低</span>
            </div>
        </div>
        <div class="confrontation-stage">
            <div class="confrontation-dialogue" id="confrontation-dialogue"></div>
        </div>
        <div class="confrontation-controls">
            <div class="dialogue-input-wrapper">
                <div class="attached-evidence" id="attached-evidence-display"></div>
                <div class="dialogue-input-container">
                    <input type="text" id="accusation-input" class="dialogue-input" 
                           placeholder="输入你的质问...">
                    <button id="attach-evidence-btn" class="attach-btn" 
                            onclick="AccusationSystem.showEvidenceAttachment()">
                        📎 附加证据
                    </button>
                    <button id="accusation-send" class="send-btn">发送</button>
                </div>
            </div>
            <button id="end-confrontation" class="secondary-btn" 
                    onclick="AccusationSystem.endConfrontation()">结束对决</button>
        </div>
    </div>
`;
步骤3：添加新的样式
css.proof-prompt {
    margin: 10px 0;
    padding: 10px;
    background: rgba(255, 107, 107, 0.1);
    border-left: 3px solid #ff6b6b;
    font-size: 16px;
}

.dialogue-input-wrapper {
    width: 100%;
}

.attached-evidence {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    min-height: 30px;
}

.attached-evidence-item {
    background: #3a3a3a;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 5px;
}

.attached-evidence-item .remove {
    cursor: pointer;
    color: #ff6b6b;
}

.attach-btn {
    padding: 10px 15px;
    background: #555;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

.evidence-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    max-height: 400px;
    overflow-y: auto;
    margin: 20px 0;
}
步骤4：修改响应解析
javascript// 在 parseResponse 方法中添加
parseResponse(response) {
    const result = {
        emotion: '平静',
        text: response,
        systemControl: null
    };
    
    // 解析情绪
    const emotionMatch = response.match(/\[([^\]]+)\]/);
    if (emotionMatch) {
        result.emotion = emotionMatch[1];
        result.text = response.replace(/\[[^\]]+\]/, '').trim();
    }
    
    // 解析系统控制
    const systemControlMatch = response.match(/<system_control>([\s\S]*?)<\/system_control>/);
    if (systemControlMatch) {
        try {
            result.systemControl = JSON.parse(systemControlMatch[1]);
            result.text = result.text.replace(/<system_control>[\s\S]*?<\/system_control>/, '').trim();
        } catch (e) {
            console.error('解析system_control失败:', e);
        }
    }
    
    return result;
}
步骤5：修改提示词构建方法
javascriptbuildAccusationPrompt(userMessage, character, accusationProfile) {
    // 分析已提交证据
    this.analyzeEvidence();
    
    // 构建对话历史
    const formattedHistory = this.dialogueHistory.map((entry, index) => {
        let text = `[第${index + 1}轮]\n侦探：${entry.detective}`;
        if (entry.evidenceSubmitted && entry.evidenceSubmitted.length > 0) {
            text += `\n（提交证据：${entry.evidenceSubmitted.join('、')}）`;
        }
        text += `\n${character.name}：${entry.npc}`;
        return text;
    }).join('\n\n');
    
    // 使用新的Prompt模板
    return `你是一个中文角色扮演游戏中的NPC。这是一个侦探推理游戏的指认阶段。
    
[... 完整的新Prompt内容 ...]

## 当前用户输入
${userMessage}`;
}
这些修改将实现：

自由对话模式，支持随时附加证据
动态显示需要证明的内容
实时判断通关条件
更自然的交互体验